---
title: "6.1 Line Search"
author: "CF Wang"
date: "2026-01-03"
format: html
---

```{r}
#| label: setup
#| echo: true
#| fig-width: 6
#| fig-height: 6
#| fig-align: center
```

```{r}
#| label: load library
#| echo: false
library(ggplot2)
```

This notebook investigates how to find the minimum of a 1D function using line search as described in Figure 6.10.

```{r}
#| label: loss function
#| fig-width: 6
#| fig-height: 6

# Let's create a simple 1D function
loss_function <- function(phi) {
  1 - 0.5 * exp(-(phi-0.65)*(phi-0.65)/0.1) - 0.45 * exp(-(phi-0.35)*(phi-0.35)/0.02)
}

draw_function <- function(loss_function, a=NULL, b=NULL, c=NULL, d=NULL) {
  # Plot the function
  phi_plot <- seq(0, 1, 0.01)
  
  par(las = 1, xaxs = "i", yaxs = "i")
  plot(phi_plot, loss_function(phi_plot),
       type = "l",lwd = 2, col = "red3",
       xlim = c(0, 1), ylim = c(0, 1),
       xlab = expression(phi),
       ylab = expression("L["*phi*"]")
       )
  if (!is.null(a) && !is.null(b) && !is.null(c) && !is.null(d)) {
    abline(v = a, col = "skyblue3")
    abline(v = b, col = "skyblue3")
    abline(v = c, col = "skyblue3")
    abline(v = d, col = "skyblue3")
  }
}

# Draw this function
draw_function(loss_function)
```

Now lets create a line search procedure to find the minimum in the range 0,1

```{r}
#| fig-width: 6
#| fig-height: 6

line_search <- function(loss_function, thresh = 0.0001, max_iter = 10, draw_flag = FALSE) {
  # Initialize four points along the range we are going to search
  a <- 0
  b <- 0.33
  c <- 0.66
  d <- 1.0
  n_iter <- 0

  # While we haven't found the minimum closely enough
  while (abs(b-c) > thresh && n_iter < max_iter) {
    # Increment iteration counter (just to prevent an infinite loop)
    n_iter <- n_iter+1

    # Calculate all four points
    lossa <- loss_function(a)
    lossb <- loss_function(b)
    lossc <- loss_function(c)
    lossd <- loss_function(d)

    if (draw_flag) {
      draw_function(loss_function, a, b, c, d)
    }

    print(sprintf("Iter %d, a=%3.3f, b=%3.3f, c=%3.3f, d=%3.3f", n_iter, a, b, c, d))

    # Rule #1 If the HEIGHT at point A is less than the HEIGHT at points B, C, and D then move them to they are half
    # as far from A as they start
    # i.e. bring them closer to the original point
    # TODO REPLACE THE BLOCK OF CODE BELOW WITH THIS RULE
    if (lossa < min(c(lossb, lossc, lossd))) {
      b <- (b + a) / 2
      c <- (c + a) / 2
      d <- (d + a) / 2
    }

    # Rule #2 If the HEIGHT at point b is less than the HEIGHT at point c then
    #                     point d becomes point c, and
    #                     point b becomes 1/3 between a and new d
    #                     point c becomes 2/3 between a and new d
    # TODO REPLACE THE BLOCK OF CODE BELOW WITH THIS RULE
    if (lossb < lossc) {
      d <- c
      b <- a + (d - a) / 3
      c <- a + (d - a) * 2 / 3
    }

    # Rule #3 If the HEIGHT at point c is less than the HEIGHT at point b then
    #                     point a becomes point b, and
    #                     point b becomes 1/3 between new a and d
    #                     point c becomes 2/3 between new a and d
    # TODO REPLACE THE BLOCK OF CODE BELOW WITH THIS RULE
    if (lossc < lossb) {
      a <- b
      b <- a + (d - a) / 3
      c <- a + (d - a) * 2 / 3
    }
  }
  # TODO -- FINAL SOLUTION IS AVERAGE OF B and C
  # REPLACE THIS LINE
  soln <- (b + c) / 2
}
    
soln <- line_search(loss_function, draw_flag=TRUE)
sprintf("Soln = %3.3f, loss = %3.3f", soln, loss_function(soln))
```

