---
title: "5.2 Binary Cross-Entropy Loss"
author: "CF Wang"
date: "2025-12-30"
format: html
---

```{r}
#| label: setup
#| echo: true
#| fig-width: 6
#| fig-height: 6
#| fig-align: center
```

```{r}
#| label: load library
#| echo: false
library(ggplot2)
```

```{r}
#| label: ReLU and shallow neural network

# Define the Rectified Linear Unit (ReLU) function
ReLU <- function(preactivation) {
  ifelse(preactivation > 0, preactivation, 0)
}

# Define a shallow neural network
shallow_nn <- function(x, beta_0, omega_0, beta_1, omega_1) {
  # Make sure that input data is (1 x n_data) array
  n_data <- length(x)
  x = matrix(x, nrow = 1, ncol = n_data)
  
  # This runs the network for ALL of the inputs, x at once so we can draw graph
  # h1 = ReLU(beta_0 %*% matrix(1, nrow = 1, ncol = n_data) + omega_0 %*% x)
  # y = beta_1 %*% matrix(1, nrow = 1, ncol = n_data) + omega_1 %*% h1
  # R vector is column oriental
  h1 <- ReLU(c(beta_0) + omega_0 %*% x)
  y <- c(beta_1) + omega_1 %*% h1
}
```

```{r}
#| label: default parameters

# Get parameters for model -- we can call this function to easily reset them
get_parameters <- function() {
  # And we'll create a network that approximately fits it
  beta_0 <- matrix(0, nrow = 3, ncol = 1)  # formerly theta_x0
  omega_0 <- matrix(0, nrow = 3, ncol = 1) # formerly theta_x1
  beta_1 <- matrix(0, nrow = 1, ncol = 1)  # formerly phi_0
  omega_1 <- matrix(0, nrow = 1, ncol = 3) # formerly phi_x

  beta_0[1,1] <- 0.3; beta_0[2,1] <- -1.0; beta_0[3,1] <- -0.5
  omega_0[1,1] <- -1.0; omega_0[2,1] <- 1.8; omega_0[3,1] <- 0.65
  beta_1[1,1] <- 2.6;
  omega_1[1,1] <- -24.0; omega_1[1,2] <- -8.0; omega_1[1,3] <- 50.0

  list(beta_0 = beta_0, omega_0 = omega_0, beta_1 = beta_1, omega_1 = omega_1)
}
```

```{r}
#| label: plot function

# Utility function for plotting data
plot_binary_classification <- function(x_model, out_model, lambda_model, x_data = NULL, y_data = NULL, title = NULL) {
  par(mfcol = c(1,2), las = 1, xaxs = "i", yaxs = "i")
  plot(x_model, out_model, type = "l", lwd = 2, col = "skyblue3",
       xlim = c(0, 1), ylim = c(-4, 4),
       # xaxp = c(0, 1, 8),
       yaxp = c(-4, 4, 8),
       xlab = expression("Input, "*x),
       ylab = "Model output"
  )
  if (!is.null(title)) {
    title(title)
  }
  
  plot(x_model, lambda_model, type = "l", lwd = 2, col = "skyblue3",
       xlim = c(0, 1), ylim = c(-0.05, 1.05),
       xlab = expression("Input, "*x),
       ylab = expression(lambda*" or Pr(y=1|x)")
  )
  if (!is.null(title)) {
    title(title)
  }
  if (!is.null(x_data)) {
    points(x_data, y_data, pch = 19)
  }
}
```

# Binary classification

In binary classification tasks, the network predicts the probability of the output belonging to class 1. Since probabilities must lie in [0,1] and the network can output arbitrary values, we map the network through a sigmoid function that ensures the range is valid.

```{r}
#| label: sigmoid function

# Sigmoid function that maps [-infty,infty] to [0,1]
sigmoid <- function(model_out) {
  # TODO -- implement the logistic sigmoid function from equation 5.18
  # Replace this line:
  sig_model_out <- 1.0 / (1.0 + exp(-model_out))
}
```

```{r}
#| label: binary classification
#| fig-width: 8
#| fig-height: 4

# Let's create some 1D training data
x_train <- c(0.09291784, 0.46809093, 0.93089486, 0.67612654, 0.73441752, 0.86847339, 0.49873225, 0.51083168, 0.18343972, 0.99380898, 0.27840809, 0.38028817, 0.12055708, 0.56715537, 0.92005746, 0.77072270, 0.85278176, 0.05315950, 0.87168699, 0.58858043)
y_train <- c(0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1)

# Get parameters for the model
params <- get_parameters()

# Define a range of input values
x_model <- seq(0, 1, 0.01)
# Run the model to get values to plot and plot it.
model_out <- shallow_nn(x_model, params$beta_0, params$omega_0, params$beta_1, params$omega_1)
lambda_model <- sigmoid(model_out)
plot_binary_classification(x_model, model_out, lambda_model, x_train, y_train)
```

The left is model output and the right is the model output after the sigmoid has been applied, so it now lies in the range [0,1] and represents the probability, that y=1. The black dots show the training data. We'll compute the likelihood and the negative log likelihood.

```{r}
#| label: bernoulli distribution
#| 
# Return probability under Bernoulli distribution for observed class y
bernoulli_distribution <- function(y, lambda_param) {
  # TODO-- write in the equation for the Bernoulli distribution
  # Equation 5.17 from the notes (you will need np.power)
  # Replace the line below
  prob <- (1.0 - lambda_param)^(1.0 - y) * lambda_param^y
}

# Let's double check we get the right answer before proceeding
sprintf("Correct answer = %3.3f, Your answer = %3.3f", 0.8, bernoulli_distribution(0, 0.2))
sprintf("Correct answer = %3.3f, Your answer = %3.3f", 0.2, bernoulli_distribution(1, 0.2))
```

Now let's compute the likelihood using this function

```{r}
#| label: likelihood
# Return the likelihood of all of the data under the model
compute_likelihood <- function(y_train, lambda_param) {
  # TODO -- compute the likelihood of the data -- the product of the Bernoulli probabilities for each data point
  # Top line of equation 5.3 in the notes
  # You will need np.prod() and the bernoulli_distribution function you used above
  # Replace the line below
  likelihood <- prod(bernoulli_distribution(y_train, lambda_param))
}

# Let's test this
params <- get_parameters()
# Use our neural network to predict the Bernoulli parameter lambda
model_out <- shallow_nn(x_train, params$beta_0, params$omega_0, params$beta_1, params$omega_1)
lambda_train <- sigmoid(model_out)
# Compute the likelihood
likelihood <- compute_likelihood(y_train, lambda_train)
# Let's double check we get the right answer before proceeding
sprintf("Correct answer = %9.9f, Your answer = %9.9f", 0.000070237, likelihood)
```

You can see that this gives a very small answer, even for this small 1D dataset, and with the model fitting quite well. This is because it is the product of several probabilities, which are all quite small themselves. This will get out of hand pretty quickly with real datasets -- the likelihood will get so small that we can't represent it with normal finite-precision math

This is why we use negative log likelihood

```{r}
#| label: negative log likelihood

# Return the negative log likelihood of the data under the model
compute_negative_log_likelihood <- function(y_train, lambda_param) {
  # TODO -- compute the likelihood of the data -- don't use the likelihood function above -- compute the negative sum of the log probabilities
  # You will need np.sum(), np.log()
  # Replace the line below
  nll <- sum(-log(bernoulli_distribution(y_train, lambda_param)))
}

# Let's test this
params <- get_parameters()
# Use our neural network to predict the mean of the Gaussian
model_out <- shallow_nn(x_train, params$beta_0, params$omega_0, params$beta_1, params$omega_1)
# Pass through the sigmoid function
lambda_train <- sigmoid(model_out)
# Compute the log likelihood
nll <- compute_negative_log_likelihood(y_train, lambda_train)
# Let's double check we get the right answer before proceeding
sprintf("Correct answer = %9.9f, Your answer = %9.9f", 9.563639387,nll)
```

Now let's investigate finding the maximum likelihood / minimum negative log likelihood solution. For simplicity, we'll assume that all the parameters are fixed except one and look at how the likelihood and negative log likelihood change as we manipulate the last parameter. We'll start with overall y_offset, beta_1 (formerly phi_0)

```{r}
#| fig-width: 8
#| fig-height: 4

# Define a range of values for the parameter
beta_1_vals <- seq(-2, 6.0, 0.1)
# Create some arrays to store the likelihoods, negative log likelihoods
likelihoods <- rep(0, length(beta_1_vals))
nlls <- rep(0, length(beta_1_vals))

# Initialise the parameters
params <- get_parameters()
for (count in 1:length(beta_1_vals)) {
  # Set the value for the parameter
  params$beta_1[1,1] = beta_1_vals[count]
  # Run the network with new parameters
  model_out <- shallow_nn(x_train, params$beta_0, params$omega_0, params$beta_1, params$omega_1)
  lambda_train <- sigmoid(model_out)
  # Compute and store the two values
  likelihoods[count] <- compute_likelihood(y_train, lambda_train)
  nlls[count] <- compute_negative_log_likelihood(y_train, lambda_train)
  # Draw the model for every 20th parameter setting
  if ((count - 1) %% 20 == 0) {
    # Run the model to get values to plot and plot it.
    model_out <- shallow_nn(x_model, params$beta_0, params$omega_0, params$beta_1, params$omega_1)
    lambda_model <- sigmoid(model_out)
    plot_binary_classification(x_model, model_out, lambda_model, x_train, y_train, title = sprintf("beta_1[1]=%3.3f", params$beta_1[1,1]))
  }
}
```

```{r}
#| label: likelihood and negative log likelihood
#| fig-width: 8
#| fig-height: 6

# Now let's plot the likelihood and negative log likelihood as a function of the value of the offset beta1
#par(mfcol = c(1,2), las = 1)
par(mar = c(5, 5, 4, 4) + 0.1, las = 1)
likelihood_color <- "red3"
nll_color <- "skyblue3"


plot(beta_1_vals, likelihoods, type = "l", lwd = 2, col = likelihood_color,
#     axes = FALSE,
     xlab = "beta_1[0]", ylab = "",
     ylim = range(likelihoods))
#axis(side = 1, at = pretty(range(beta_1_vals)))

mtext("likelihood", las = 0, side = 2, line = 4, col = likelihood_color)
axis(side = 2, at = pretty(range(likelihoods)), col.axis = likelihood_color, col.ticks = likelihood_color)

par(new = TRUE)
plot(beta_1_vals, nlls, type = "l", lwd = 2, col = nll_color,
     axes = FALSE, xlab = "", ylab = "",
     ylim = range(nlls))
axis(side = 4, at = pretty(range(nlls)), col.axis = nll_color, col.ticks = nll_color)
mtext("negative log likelihood", las = 0, side = 4, line = 2, col = nll_color)

abline(v = beta_1_vals[which.max(likelihoods)], lty = 3, col = nll_color)
```

```{r}
#| label: best model
#| fig-width: 8
#| fig-height: 4

# Hopefully, you can see that the maximum of the likelihood fn is at the same position as the minimum negative log likelihood
# Let's check that:
sprintf("Maximum likelihood = %f, at beta_1=%3.3f", likelihoods[which.max(likelihoods)], beta_1_vals[which.max(likelihoods)])
sprintf("Minimum negative log likelihood = %f, at beta_1=%3.3f", nlls[which.min(nlls)], beta_1_vals[which.min(nlls)])

# Plot the best model
params$beta_1[1,1] <- beta_1_vals[which.min(nlls)]
model_out <- shallow_nn(x_model, params$beta_0, params$omega_0, params$beta_1, params$omega_1)
lambda_model <- sigmoid(model_out)
plot_binary_classification(x_model, model_out, lambda_model, x_train, y_train, title = sprintf("beta_1[1]=%3.3f", params$beta_1[1,1]))
```

They both give the same answer. But you can see from the likelihood above that the likelihood is very small unless the parameters are almost correct. So in practice, we would work with the negative log likelihood.

Again, to fit the full neural model we would vary all of the 10 parameters of the network in the $\beta_0, \Omega_0, \beta_1, \Omega_1$ until we find the combination that have the maximum likelihood / minimum negative log likelihood.
