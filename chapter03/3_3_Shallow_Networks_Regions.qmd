---
title: "3.3 -- Shallow Networks Regions"
author: "CF Wang"
date: "2026-01-18"
format: html
---

```{r}
#| label: setup
#| fig-width: 6
#| fig-asp: 0.618
#| fig-align: center
#| out-width: 70%

library(ggplot2)
library(scales)
```

The purpose of this notebook is to compute the maximum possible number of linear regions as seen in figure 3.9 of the book.

The number of regions  created by a shallow neural network with  inputs and  hidden units is given by Zaslavsky's formula:

$$
N = \sum_{j=0}^{D_i}\binom{D}{j} = \sum_{j}^{D_i}\frac{D!}{(D-j)!j!}
$$

```{r}
#| label: number_regions

number_regions <- function(Di, D) {
  sum(choose(D, seq(0, Di)))
}
```

```{r}
#| label: test-number_regions

# Calculate the number of regions for 2D input (Di=2) and 3 hidden units (D=3) as in figure 3.8j
N <- number_regions(2, 3)
sprintf("Di=2, D=3, Number of regions = %.0f, True value = 7", N)

# Calculate the number of regions for 10D input (Di=10) and 50 hidden units (D=50)
N <- number_regions(10, 50)
sprintf("Di=10, D=50, Number of regions = %.0f, True value = 13432735556", N)
```

This works but there is a complication. If the number of hidden units $D$ is fewer than the number of input dimensions $D_i$, the formula will fail. When this is the case, there are just $2^D$ regions (see figure 3.10 to understand why).

Let's demonstrate this:

```{r}
#| label: number_regions-could-fail

# Depending on how you implemented it, the calculation may fail when Di > D (not to worry...)
N <- number_regions(10, 8)
sprintf("Di=10, D=8, Number of regions = %.0f, True value = 256", N)
```

```{r}
#| label: figure-3.9a
#| warning: false

# Now let's plot the graph from figure 3.9a
dims <- c(1, 5, 10, 50, 100)
regions <- array(c(rep(0, length(dims)), rep(0, 1000)), dim = c(length(dims), 1000))
for (c_dim in seq(length(dims))) {
  D_i <- dims[c_dim]
  cat(sprintf("Counting regions for %d input dimensions\n", D_i))
  for (D in seq(1000)) {
    regions[c_dim, D] <- number_regions(min(D_i,D), D)
  }
}

colors <- c("Di=1" = "black", "Di=5" = "blue3", "Di=10" = "magenta3", "Di=50" = "cyan3", "Di=100" = "yellow3")
xv <- 1:1000
ggplot() +
  xlim(0, 1000) + ylim(1e1, 1e150) +
  scale_y_log10(labels = trans_format("log10", math_format(10^.x))) +
  geom_line(aes(xv, regions[1,], color = "Di=1")) +
  geom_line(aes(xv, regions[2,], color = "Di=5")) +
  geom_line(aes(xv, regions[3,], color = "Di=10")) +
  geom_line(aes(xv, regions[4,], color = "Di=50")) +
  geom_line(aes(xv, regions[5,], color = "Di=100")) +
  labs(y = "Number of regions, N", x = "Number of hidden units, D", color = NULL) +
  scale_color_manual(
    values = colors,
    breaks = c("Di=1", "Di=5", "Di=10", "Di=50", "Di=100"),
    labels = c(
      expression(D[i]==1),
      expression(D[i]==5),
      expression(D[i]==10),
      expression(D[i]==50),
      expression(D[i]==100)
    )
  ) +
  theme(
    legend.background = element_rect(fill = "white", color = "black", linewidth = 0.1),
    legend.position = c(0.02, 0.98),
    legend.justification = c("left", "top"),
    legend.text = element_text(size = 12),
    legend.key.size = unit(1.0, "lines")
  )
```

```{r}
#| label: number_parameters

# Now let's compute and plot the number of regions as a function of the number of parameters as in figure 3.9b
# First let's write a function that computes the number of parameters as a function of the input dimension and number of hidden units (assuming just one output)
number_parameters <- function(D_i, D) {
  # TODO -- replace this code with the proper calculation
  (D_i + 1) * D + D + 1
}
```
```{r}
#| label: test-number_parameters

# Now let's test the code
N <- number_parameters(10, 8)
sprintf("Di=10, D=8, Number of parameters = %d, True value = 97", N)
```

```{r}
#| label: figure-3.9b
#| warning: false

# Now let's plot the graph from figure 3.9b (takes ~1min)
dims <- c(1, 5, 10, 50, 100)
regions <- array(c(rep(0, length(dims)), rep(0, 200)), dim = c(length(dims), 200))
params <- array(c(rep(0, length(dims)), rep(0, 200)), dim = c(length(dims), 200))

# We'll compute the five lines separately this time to make it faster
for (c_dim in seq(length(dims))) {
  D_i <- dims[c_dim]
  sprintf("Counting regions for %d input dimensions", D_i)
  for (c_hidden in 1:200) {
    # Iterate over different ranges of number hidden variables for different input sizes
    D <- c_hidden * 500 / D_i
    params[c_dim, c_hidden] <- D_i * D + D + D + 1
    regions[c_dim, c_hidden] <- number_regions(min(D_i, D), D)
  }
}

colors <- c("Di=1" = "black", "Di=5" = "blue3", "Di=10" = "magenta3", "Di=50" = "cyan3", "Di=100" = "yellow3")
ggplot() +
  xlim(0, 100000) + ylim(1e1, 1e150) +
  scale_y_log10(
    labels = trans_format("log10", math_format(10^.x)) # Format as powers of 10
  ) +
  labs(y = "Number of regions, N", x = "Number of parameters, D", color = NULL) +
  geom_line(aes(params[1,], regions[1,], color = "Di=1"), linewidth = 0.75) +
  geom_line(aes(params[2,], regions[2,], color = "Di=5"), linewidth = 0.75) +
  geom_line(aes(params[3,], regions[3,], color = "Di=10"), linewidth = 0.75) +
  geom_line(aes(params[4,], regions[4,], color = "Di=50"), linewidth = 0.75) +
  geom_line(aes(params[5,], regions[5,], color = "Di=100"), linewidth = 0.75) +
  scale_color_manual(
    values = colors,
    breaks = c("Di=1", "Di=5", "Di=10", "Di=50", "Di=100"),
    labels = c(
      expression(D[i]==1),
      expression(D[i]==5),
      expression(D[i]==10),
      expression(D[i]==50),
      expression(D[i]==100)
    )
  ) +
  theme(
    legend.background = element_rect(fill = "white", color = "black", linewidth = 0.1),
    legend.position = c(0.02, 0.98),
    legend.justification = c("left", "top"),
    legend.text = element_text(size = 12),
    legend.key.size = unit(1.0, "lines")
  )
```
